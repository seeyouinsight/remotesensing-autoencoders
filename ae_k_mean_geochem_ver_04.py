# -*- coding: utf-8 -*-
"""AE_K-Mean_GeoChem_ver_04.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FtsuV1Wjpkd5ZFzFziXdMy9oEypcTDbr

# Autoencoder and K-means

# Dimensionality reduction with Autoencoders versus PCA
"""

!pip install spectral
!pip install rasterio

from google.colab import drive
drive.mount('/content/drive')

"""## Use [rasterio](https://rasterio.readthedocs.io/en/latest/) package to open images.

Geographic information systems use GeoTIFF and other formats to organize and store gridded raster datasets such as satellite imagery and terrain models. Rasterio reads and writes these formats and provides a Python API based on Numpy N-dimensional arrays and GeoJSON.
"""

# Basic import

from time import time
import rasterio as rio
from sklearn.preprocessing import minmax_scale
from sklearn import cluster
from sklearn.decomposition import PCA

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow import keras

# reading the HSI images (dataset)
# X, y = datasets.make_classification(n_samples=10000, n_features=50, n_redundant=10, n_informative=10,
                          #  random_state=1, n_clusters_per_class=2,n_classes=3, class_sep=2)
                           
# # divide data in Train - Validation - Test
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
# X_tr, X_valid, y_tr, y_valid = train_test_split(X_train, y_train, test_size=0.2, random_state=42) 

# # Standardize Data
# sc = StandardScaler()
# X_tr_std = sc.fit_transform(X_tr)
# X_valid_std = sc.transform(X_valid)
# X_test_std = sc.transform(X_test)

"""## Load and process Dataset 

Hyperspectral Image(HSI) data often contains hundreds of spectral bands over the same spatial area which provide valuable information to identify the various materials. In HSI, each pixel can be regarded as a high dimensional vector whose entries correspond to the spectral reflectance from visible to infrared.

## Visualizing the data

Hyper-spectral image (HSI) satellite
"""

!pip install hyperspy

import hyperspy.api as hs
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image

img_15 = Image.open('drive/MyDrive/VAE_GeoChem/Wilcannia_RockUnits_15m.tif')
img_30 = Image.open('drive/MyDrive/VAE_GeoChem/Wilcannia_RockUnits_30m.tif')
# Loading data
# s = hs.load("drive/MyDrive/VAE_GeoChem/Wilcannia_RockUnits_15m.tif")

# img.save("drive/MyDrive/VAE_GeoChem/Wilcannia_RockUnits_30m.png")
img_15

# im = Image.open('tmp.png')
# im.show()

img_30

"""## load the data"""

# Importing the data
import rasterio as rio
data_raster = rio.open('drive/MyDrive/VAE_GeoChem/Playa_Image.tif')
data_test   = rio.open('drive/MyDrive/VAE_GeoChem/Playa_Training.tif')

# data_raster = rio.open('drive/MyDrive/VAE_GeoChem/Wilcannia_ASTER.tif')
# data_test   = rio.open('drive/MyDrive/VAE_GeoChem/Wilcannia_RockUnits_15m.tif')
# print(data_raster.meta)
# Wilcannia_ASTER.tif
# Wilcannia_RockUnits_15m.tif
## Visualizing the data
# Reading and enhancing
data_array = data_raster.read() # reading the data
vmin, vmax = np.nanpercentile(data_array, (1,99)) # 5-95% pixel values stretch

data_array_test = data_test.read() # reading the data
vmin, vmax = np.nanpercentile(data_array_test, (1,99)) # 5-95% pixel values stretch
# Plotting the enhanced image
# fig = plt.figure(figsize=[20,20])
# plt.axis('off')
# plt.imshow(data_array[0, :, :], vmin=vmin, vmax=vmax)
# plt.show()

"""### Reshaping the `train data` from brc to rcb Creating an empty array with the same dimension and data type.

Extracting pixels of the HSI is one of the important preprocessing tasks. This makes easier to handle the data and also to implement machine learning algorithms such as classification, clustering e.t.c
"""

imgxyb = np.empty((data_raster.height, data_raster.width, data_raster.count), data_raster.meta['dtype'])
# Looping through the bands to fill the empty array
for band in range(imgxyb.shape[2]):
    imgxyb[:,:,band] = data_raster.read(band+1)

# Reshaping the train data from rcb to samples and features
data_reshaped = imgxyb.reshape(imgxyb.shape[0]*imgxyb.shape[1], -1)
# Scaling
data_reshaped = minmax_scale(data_reshaped, feature_range=(0, 1), axis=0, copy=False)
data_reshaped.shape

"""### Reshaping the `test data` from brc to rcb Creating an empty array with the same dimension and data type"""

imgxyb_test = np.empty((data_test.height, data_test.width, data_test.count), data_test.meta['dtype'])
# Looping through the bands to fill the empty array
for band in range(imgxyb_test.shape[2]):
    imgxyb_test[:,:,band] = data_test.read(band+1)

# Reshaping the test data from rcb to samples and features
data_reshaped_test = imgxyb_test.reshape(imgxyb_test.shape[0]*imgxyb_test.shape[1], -1)
# Scaling
data_reshaped_test = minmax_scale(data_reshaped, feature_range=(0, 1), axis=0, copy=False)
data_reshaped_test.shape

"""## Data split: Train - Validation - Test

The procedure involves taking a dataset and dividing it into two subsets. The first subset is used to fit the model and is referred to as the training dataset. The second subset is not used to train the model; instead, the input element of the dataset is provided to the model, then predictions are made and compared to the expected values. This second dataset is referred to as the test dataset.



*   Train Dataset: Used to fit the machine learning model.
*   Test Dataset: Used to evaluate the fit machine learning model.


"""

# divide data in Train - Validation - Test
# X_train, X_test, y_train, y_test = train_test_split(data_reshaped, data_reshaped_test, test_size=1.0, random_state=42)
# X_tr, X_valid, y_tr, y_valid = train_test_split(X_train, y_train, test_size=0.2, random_state=42)

"""###  Standardize Data:

the process of converting data to a common format to enable users to process and analyze it

"""

sc = StandardScaler()
X_tr_std = sc.fit_transform(data_reshaped)
# X_valid_std = sc.transform(X_valid)
X_test_std = sc.transform(data_reshaped_test)

print(X_tr_std)
print(X_tr_std.shape)

"""#### Scaled Silhouette Score for original data

"""



from sklearn.metrics import silhouette_score
kmeans_original_scale = cluster.KMeans(n_clusters=5, n_init=100, max_iter=200, init='k-means++', random_state=42).fit(X_tr_std)
print('KMeans, original data, Scaled Silhouette Score: {}'.format(silhouette_score(X_tr_std, kmeans_original_scale.labels_, metric='euclidean')))

"""## Let’s set up  Auto-encoderE: """

# Encoder (input bands)7-7-7-7-7-7-7-6-5
encoder = keras.models.Sequential([
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(6, input_shape=[7]),
    keras.layers.Dense(5, input_shape=[6]),
])

# Decoder 5-6-7-7-7-7-7-7-7 (output dimension/bands)
decoder = keras.models.Sequential([
    keras.layers.Dense(6, input_shape=[5]),
    keras.layers.Dense(7, input_shape=[6]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
    keras.layers.Dense(7, input_shape=[7]),
])

# define the auto-encoder model
autoencoder = keras.models.Sequential([encoder, decoder])
autoencoder.compile(loss='mse', optimizer = keras.optimizers.SGD(learning_rate=0.01))

# epochs (hyperparameter)
epochs = 15

# saving the loss in history 
history = autoencoder.fit(X_tr_std,X_tr_std, epochs=epochs,validation_data=(X_test_std,X_test_std),
                         callbacks=[keras.callbacks.EarlyStopping(patience=10)])
# train the Auto-encoder model                        
codings = encoder.predict(X_tr_std)

autoencoder.summary()

X_tr_std.shape

autoencoder.count_params()

print(history.history.keys())

print(len(history.history['loss']))
train_loss_val = history.history['loss']
test_loss_val = history.history['val_loss']

train_loss = [i * 1000 for i in train_loss_val]
test_loss  = [i * 1000 for i in test_loss_val]

"""## plot the train and validation loss"""

pd.DataFrame(history.history).plot(figsize=(8,5))
plt.ylabel('Loss * 1000')
plt.xlabel('Epochs')
plt.savefig("summarize history for loss.jpg")



pd.DataFrame(history.history).plot(figsize=(8,5))
plt.ylabel('Loss')
plt.xlabel('Epochs')
plt.savefig("summarize history for loss.jpg")

"""## PCA implementation: [paper](https://www.sciencedirect.com/science/article/pii/S1877050919321507)

PCA  finds low dimensional approximations to the data by
projecting the data onto linear subspaces

Principal Components Analysis (PCA)
1. Compute the sample covariance matrix Σ =b n
−1 Pn
i=1(Xi − Xn)(Xi − Xn)
T
.
2. Compute the eigenvalues λ1 ≥ λ2 ≥ · · · and eigenvectors e1, e2, . . . , of Σ. b
3. Choose a dimension k.
4. Define the dimension reduced data Zi = Tk(Xi) = X +
Pk
j=1 βijej where βij =
hXi − X, ej i.
"""

from sklearn.decomposition import PCA
# pca = PCA(n_components=5,svd_solver='auto')
# scores = pca.fit_transform(X_tr_std) # u

# PCA
pca = PCA(n_components=5)
scores = pca.fit_transform(data_reshaped)
var_ratio = pca.explained_variance_ratio_
values = pca.singular_values_

print(var_ratio.shape)
print(values)

"""### function to plot and display the image"""

def plot_data(data,fig_name):
  fig = plt.figure(figsize = (15, 10))
  plt.imshow(data, cmap = 'nipy_spectral')
  plt.colorbar()
  plt.axis('off')
  plt.show()
  plt.savefig(fig_name)

"""# Clustring: [blog](https://developers.google.com/machine-learning/clustering/clustering-algorithms)

Clustering or cluster analysis is a machine learning technique, which groups the unlabelled dataset. It can be defined as "A way of grouping the data points into different clusters, consisting of similar data points.

When choosing a clustering algorithm, you should consider whether the algorithm scales to your dataset. Datasets in machine learning can have millions of examples, but not all clustering algorithms scale efficiently. Many clustering algorithms work by computing the similarity between all pairs of examples. This means their runtime increases as the square of the number of examples , denoted as n in O(nxn) complexity notation.  O(nxn) algorithms are not practical when the number of examples are in millions. Here, we focuses on the **`k-means`** algorithm, which has a complexity of O(n), meaning that the algorithm scales linearly with .

# a. PCA -> K-means

applying the K-means on top of PCA
"""

# K-means
cl = cluster.KMeans(n_clusters=5) # Creating an object of the classifier
components_num = 5
param = cl.fit(scores[:,:components_num]) # Training
img_c = cl.labels_ # Getting the labels of the classes
img_cl = img_c.reshape(data_array[0,:,:].shape) # Reshaping the labels to a 3D array (single band)
plot_data(img_cl, 'PCA_k_means.png')

"""### Standardization
As aforementioned, the standardization of data will ultimately bring all features to the same scale and bringing the mean to zero and the standard deviation to 1
"""

df = scores[:,:components_num]
scaler = StandardScaler()
scaler.fit(df)
pca_df_scale = scaler.transform(df)

pca_df_scale.shape

"""## PCA Scaled Silhouette Score"""

from sklearn.metrics import silhouette_score
kmeans_pca_scale = cluster.KMeans(n_clusters=5, n_init=100, max_iter=400, init='k-means++', random_state=42).fit(pca_df_scale)
print('KMeans PCA Scaled Silhouette Score: {}'.format(silhouette_score(pca_df_scale, kmeans_pca_scale.labels_, metric='euclidean')))

# print(X_scale)

# df_scale2 = df
# pca2 = PCA(n_components=5).fit(df_scale2) # max n_components = 7 (Playa dataset)
# pca2d = pca2.transform(df_scale2)
# plt.figure(figsize = (10,10))
# sns.scatterplot(pca2d[:,0], pca2d[:,1], 
#                 hue=labels_scale, 
#                 palette='Set1',
#                 s=100, alpha=0.2).set_title('KMeans Clusters (5) Derived from Original Dataset', fontsize=15)
# plt.legend()
# plt.ylabel('PC2')
# plt.xlabel('PC1')
# plt.show()

# df_scale2 = df_scale.copy()
# kmeans_scale = KMeans(n_clusters=4, n_init=100, max_iter=400, init='k-means++', random_state=42).fit(df_scale2)
# print('KMeans Scaled Silhouette Score: {}'.format(silhouette_score(df_scale2, kmeans_scale.labels_, metric='euclidean')))
# labels_scale = kmeans_scale.labels_
# clusters_scale = pd.concat([df_scale2, pd.DataFrame({'cluster_scaled':labels_scale})], axis=1)

# import sklearn
# sklearn.metrics.silhouette_score(X, labels, *, metric='euclidean', 
#                                  sample_size=None, random_state=None, **kwds)

"""## b. *Auto-encoder -> K-means*"""

print(codings.shape)

# K-means
cl = cluster.KMeans(n_clusters=5) # Creating an object of the classifier
param = cl.fit(codings) # Training
img_c = cl.labels_ # Getting the labels of the classes
# img_cl_pred = cl.predict(data_ae)
img_c2 = img_c.reshape(data_array[0,:,:].shape) # Reshaping the labels to a 3D array (single band)
plot_data(img_c2, 'AE_k_means.png')

print(img_c.shape)
print(data_array.shape)

"""## AE Scaled Silhouette Score"""

from sklearn.metrics import silhouette_score
kmeans_AE_scale = cluster.KMeans(n_clusters=5, n_init=100, max_iter=400, init='k-means++', random_state=42).fit(codings)
print('KMeans AE Scaled Silhouette Score: {}'.format(silhouette_score(codings, kmeans_AE_scale.labels_, metric='euclidean')))

"""## 3. Validation: Adjusted Rand Index

![ARI.jpg](data:image/jpeg;base64,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gURgjBBIEjhGDzurmggkAolAIpAIJAKJQCKQCCQCiUCSwGwDiUAikAgkAolAIpAIJAKJQCKQCIwRAkkCx+hhZ1UTgUQgEUgEEoFEIBFIBBKBRCARSBKYbSARSAQSgUQgEUgEEoFEIBFIBBKBMULgT8eorlnVRCARSASmIDAxMVH9yZ/8yZRz+U8ikAgkAonAaCJwxx13VA899FD1k5/8pPrxj39c/Y//8T+q//k//2f1y1/+svrFL35R/fVf/3V13nnnVS996UvnrAI5jswZ1JnRkBFIEjhkQDO5RCARmD8IIIB33XVX9e53v7t68pOfPLSC/9mf/Vm13HLLVYsWLaqe85znlM8mm2wylPT/4z/+o/rZz35Wvf/9769++MMfVn/6p3/oxv/Lf/kv5fsTntDewcN9v//97yvH//t//2/1u9/9rlpjjTWqk08+uXrKU54ylLLN10Qef/zx6tBDD61+9atflUkBGMLTp90kQWDoSAGcTqQRn0i7ma60yNFHH12tt956VafnOF1e+XsisJARuPHGG6vrrruu+l//63+V91Vf6135P//n/5R+7a/+6q/mvPre5Y9//OPVhRdeWD31qU8dWv5PetKTqmc84xll/DCWPP/5z6/WWmutoaRvDECmjX3GAuOIesQ40uyfItP/9//+3+Q44rsPwn3MMcfEJXmcRwgkCZxHDyuLmggkAsNHADEywCIA//t//+/qt7/9bfXTn/60EK12uT33uc+tVlhhhcoAHYq7ATOUEPf4Lr0HH3ywoqQggvfdd19REAzia665ZvVf/+t/bZf8tOfkJW9l+N73vle+K/N//+//vXr00Uer3/zmN9UTn/jEKemoo0F+/fXXr5ZZZplCXJ7+9KeX63ohMVMSW4D/wIdFgTKpDbAswFM7cC6ItqpTeiialDNWB8/XM2mHo/Ou1x58KFv/9m//VqwW8pD2n//5n5cjpcz/hx9+eCnDoO1jAT6erFIiMInApptuWt4p79K//Mu/VJ///OerX//61+X9874tLdEH6+f/+Z//ubzr//7v/17643/9139dokje+ec973mlD9G31PsO/YRxRb9hcko/dO+995aJutVXX71abbXVyn3rrrtu+Y60DSLylNZf/uVfVv/0T/9U+riwqD7yyCOFUCtnXZTN9S984QvLWKbOK620Uqlv/br8Pn8QSBI4f55VljQRSARmAYEXvOAF1a677loUdAO3Qfsb3/hGUS64FwXRkzVr4bbbblssNWZ8DdSE8uFeiolzP//5z8vAajClFNx2223VlVdeWT3zmc+s9txzz+of//Efq4033rgoDRT/fkRe8n7xi19crbrqqiVvBOaxxx6r/uIv/qL69re/XQhNPc1ll1222mijjaotttiietaznlWIB/Ky/PLLFxJZv3Ycv/+3//bfqu23377McFOOEPjvfve7RflidWV1qIuJgM0226w8T4S8k3hWyB3lyofSJL0f/ehH5TvlS1uJdiQd+a6yyioDTxJ0KkueTwTmOwLezR122KF81IUnhPfrpptuKpMrS5MEbrPNNtWKK65Y+hDvOoL6hS98obrnnnvKGFDHnpfIzjvvXEiYPrs+xpjE87++Qt+ABJrsQwivuOKK0o+YRNxvv/0Kydxggw1KP1RPv5fvyKe8dttttzJ26YOU2ZjlO2yb/R6S+6IXvaj0fepg7NL/IYIp8xSB1kuVkggkAolAIlBDoEXcJs4555yJFunj61c+rcFuokUYJ/zWj7j+Ix/5yMTKK6880Ro0S1qtGdaJFpmcaJHMidaA209yXa9tubZO7L///pNljrLvsssuXe/LH5dEwHNprS2aaFlup+DZmgmfuPrqq5e8oc8zLdI+cfzxx0+0LAJT0j/ppJMmWopYn6nl5YnAeCJw++23T7Qm8co7pH/Vzzo3CvLwww9PnHDCCVPe75YXwcSrX/3qvorXIoUT0mq5XE60PDkmWmS3pKkvOvjggydak1ZDHUeuuuqqiZaL55RyG0s+8IEP9FXuvHj0EehvCnqeEt0sdiKQCCQC/SDAMmT9Rd3VxnfnW916P0kV98sWMSvWwH333be43bAY3nnnnZV1ghdffHFx/+sr0Q4Xs/L51IXrIrfFlP4R4LLlmYewNMB3GK6az372s4vr5+LFi6sjjzyyWHTlY+bfDH1KItAJgX77oE7pLITz3k/WtFGUv/mbvylW/XrZuFj223/od1jhjjrqqOprX/taGTec47Vy6aWXVi972cuqu+++e4pHQT3Pfr/zRGiOGerSb7n7zTevn3sEkgTOPeaZYyKQCIw4AlxlDIIG2hDnnva0p005F791O0qDotKaoa4OO+yw6pBDDilpcLXhFnjWWWdVF1xwQbckev5NgJdmkJd253pOcIwvpGhr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CHkUIYMyd55OwnVPeH/KfTdRvmYZm/93uz9/m4rAXGAXSj+ryDvf+c7ijrfqqqtWixYtmlqYDv+5n1Vv3333rV74whdWRx11VLEAdir7e97znup1r3tdaSeUwosvvri6/vrrCwHpkEVfpxEwpGgQsffZddddN3nreuutV22yySaFpEyebHxhmVt33XWLZQQWcEQmBy2DtZhcPG+77bbyrtbJE0wFPWI9q2/psnjx4kLgG0Xr6V9rGLlr3nPPPWXNXtPNr56I37hvxrM1WaC+3QRZcB8y3Uxb3XbfffdKe/MdYZPeAw88MPD6MkTy0Ucfre66664l6sPV93nPe161/vrrl/IoN/J34403DmwNhEF9TSZsAp9uuCyt32ZaPvez3DYnE7V9BK/TZAScrr766uqkk06qPv3pT3et/ijj17Xg+WPfCCwYEhgDaR2Bdufqv+f3RCARSATaIUA5NkNdFwoShc06mkFFcAbrs5qDLIWVBaiTUEopV00lrnk9BdanLhQkCkBKfwgYPzzvpoWCItt8fv2lPPVqaT3W2roBAbSWT34mC3w6SX1su++++ypBX1hEtC+uoN3EOjrbQ7AKytvn/PPPr84777wpynS3NLr9xoqGlPYrXAK/9KUvVV/96lfLrcqlXrvuuuu0Se24447VoYceOvlcWEV9+pHAlBWLRZaFEeFqJyKvcrdVRsICKwLrIPK5z32uRHXccssti9uuNKIszfT0PSKURj+g30Agu4k1fvqWpht6/Z4DDzyw2nPPPUt99HOf//zny2bkrulUlvr99e+XX3755B6XUc76774fdNBB1VZbbVXy0zddeOGFfbnU1st0ww03FOuldJ1HYpvvrN+WhihHu/64Obb0UzaYmvTgKRDtL+7/+c9/XjwB4v/60ZjG5dh4UJ/YqF8T35WviaF6NM/F9XmcvwgsGBLoZTADedVVV5V1EQaU5gsyfx9TljwRSATmEgF9h1nVuisTEuac46BiBpciZ41WXVgB77///vqpKcqXdVIU0jXXXHPKNc1/zAI3LSDSni50eF2paqa50P/vVHeKUjs3tU4z7YPgxN0Q6Tj11FMrLoFIp7a3qGUFXGGFFTom6RoKnzWAF110UQnywkWMRYd0qlMkuMUWW5Sooa7zsa0CC9zHP/7xKW0+ru/nSNG86aabijUt7puuPK674oorCgFEsgmi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)

The Rand Index computes a similarity measure between two clusterings by considering all pairs of samples and counting pairs that are assigned in the same or different clusters in the predicted and true clusterings.
"""

sklearn.metrics.adjusted_mutual_info_score(labels_true, labels_pred, *, average_method='arithmetic')

"""## 4. Validation: Calinski-Harabasz Index (*C-H index*)
Calinski-Harabasz Index is also known as the Variance Ratio Criterion.

The score is defined as the ratio between the within-cluster dispersion and the between-cluster dispersion. The C-H Index is a great way to evaluate the performance of a Clustering algorithm as it does not require information on the ground truth labels.

The higher the Index, the better the performance.
"""

sklearn.metrics.calinski_harabasz_score(X, labels)

"""## AUC"""

from sklearn.metrics import roc_auc_score
auc = roc_auc_score(labels, scores)

codings_train = encoder.predict(X_tr_std)
codings_test = encoder.predict(X_test_std)
scores_train = pca.transform(X_tr_std)
scores_test = pca.transform(X_test_std)

pd.DataFrame(scores_train, columns=['PC'+str(i) for i in range(pca.n_components_)]).std().plot(kind='bar', color='#5394b8', width=0.7, fontsize=10)
plt.ylabel('scores std. dev.', fontsize=13)
plt.xlabel('Principal components', fontsize=13)
plt.savefig('scores_std_dev.png')
# plt.savefig("PCA.jpg")

pd.DataFrame(codings_train, columns=['Z'+str(i) for i in range(5)]).std().plot(kind='bar', color='#5aa169', rot=1, width=0.6, fontsize=10) # range(no of components)
plt.ylabel('E-D LVs std. dev.',fontsize=13)
plt.xlabel('Latent values (z)', fontsize=13)
plt.savefig('E-D_LVs_std_dev.png')

sns.heatmap(pd.DataFrame(scores_train, columns=['PC'+str(i) for i in range(pca.n_components_)]).corr(), vmin=-1, vmax=+1, cmap='coolwarm', annot=True)

sns.heatmap(pd.DataFrame(codings_train, columns=['E'+str(i) for i in range(5)]).corr(), vmin=-1, vmax=+1, cmap='coolwarm', annot=True)

autoencoder.summary()

"""## NonLinear Stacked Encoder-Decoder
The nonlinear stacked AE will be easily implemented as the stacked AE but with an activation function. We also introduced a decay constant over the SGD optimizer so that the learning rate will decrease over time. We pick “selu” as activation layer for all layers. Note that here we have increased the complexity even more: we could try to find the best number of hidden layers, the best activation function and shape of each of the layers for the specific problem.
"""

nl_st_encoder = keras.models.Sequential([
    keras.layers.Dense(6, input_shape=[7], activation='relu'),
    keras.layers.Dense(5, activation='selu'),
    keras.layers.Dense(5, activation='selu'),
])

nl_st_decoder = keras.models.Sequential([
    keras.layers.Dense(5, input_shape=[5], activation='selu'),
    keras.layers.Dense(6, activation='selu'),
    keras.layers.Dense(7, activation='relu'),
])

nl_st_autoencoder = keras.models.Sequential([nl_st_encoder, nl_st_decoder])
nl_st_autoencoder.compile(loss='mse', optimizer = keras.optimizers.SGD(learning_rate=0.01, decay=1e-4))
nl_st_autoencoder.summary()


history = nl_st_autoencoder.fit(X_tr_std,X_tr_std, epochs=10,validation_data=(X_valid_std,X_valid_std),
                         callbacks=[keras.callbacks.EarlyStopping(patience=10)],verbose=1)

nl_st_codings_train = nl_st_encoder.predict(X_tr_std)
nl_st_codings_test = nl_st_encoder.predict(X_test_std)

"""# Conclusion 
Our aim was to compare PCA and an AutoEncoder neural network to see if the dimensionality reduction was comparable.

- We looked at the properties of the scores/encodings and we saw that encodings from the AE have some correlations (the covariant matrix is not diagonal like in PCA), and also that their standard deviation is similar.
Starting from a simple linear undercomplete AE with just 1 layer, we saw that increasing complexity helped the model reach better performances, evaluated in terms of classification accuracy.
- Finally, we saw that a non linear model can still perform better than the other two (one layer AE and stacked AE) but the performance is still comparable to that of PCA in this dataset.
"""



"""https://github.com/rasbt/deeplearning-models/tree/master/pytorch_ipynb/autoencoder"""



"""# VAE : test"""

import torch; torch.manual_seed(0)
import torch.nn as nn
import torch.nn.functional as F
import torch.utils
import torch.distributions
import torchvision
import numpy as np
import matplotlib.pyplot as plt; plt.rcParams['figure.dpi'] = 200
device = 'cuda' if torch.cuda.is_available() else 'cpu'

class VariationalEncoder(nn.Module):
    def __init__(self, latent_dims):
        super(VariationalEncoder, self).__init__()
        self.linear1 = nn.Linear(7, 6)
        self.linear2 = nn.Linear(5, latent_dims)
        self.linear3 = nn.Linear(5, latent_dims)

        self.N = torch.distributions.Normal(0, 1)
        self.N.loc = self.N.loc.cuda() # hack to get sampling on the GPU
        self.N.scale = self.N.scale.cuda()
        self.kl = 0

    def forward(self, x):
        x = torch.flatten(x, start_dim=1)
        x = F.relu(self.linear1(x))
        mu =  self.linear2(x)
        sigma = torch.exp(self.linear3(x))
        z = mu + sigma*self.N.sample(mu.shape)
        self.kl = (sigma**2 + mu**2 - torch.log(sigma) - 1/2).sum()
        return z

class Decoder(nn.Module):
    def __init__(self, latent_dims):
        super(Decoder, self).__init__()
        self.linear1 = nn.Linear(5, 6)
        self.linear2 = nn.Linear(6, 7)

    def forward(self, z):
        z = F.relu(self.linear1(z))
        z = torch.sigmoid(self.linear2(z))
        return z

class VariationalAutoencoder(nn.Module):
    def __init__(self, latent_dims):
        super(VariationalAutoencoder, self).__init__()
        self.encoder = VariationalEncoder(latent_dims)
        self.decoder = Decoder(latent_dims)

    def forward(self, x):
        z = self.encoder(x)
        return self.decoder(z)

def train(autoencoder, data, epochs=20):
    opt = torch.optim.Adam(autoencoder.parameters())
    for epoch in range(epochs):
        for x, y in data:
            x = x.to(device) # GPU
            opt.zero_grad()
            x_hat = autoencoder(x)
            loss = ((x - x_hat)**2).sum() + autoencoder.encoder.kl
            loss.backward()
            opt.step()
    return autoencoder

vae = VariationalAutoencoder(latent_dims).to(device) # GPU
vae = train(vae, data)









# mnist_vae_viz.py

# PyTorch variational autoencoder visualization
# compress each 9 bands to 5 values then plot


# PyTorch 1.8.0-CPU Anaconda3-2020.02  Python 3.7.6
# CPU, Windows 10

import numpy as np
import torch as T
import matplotlib.pyplot as plt
import torchvision as tv  # to visualize fakes

device = T.device("gpu")

# -----------------------------------------------------------

class dataset_playa():
  # for an Autoencoder (not a classifier)
  # assumes data has been converted to tab-delim text files:
  # 7 pixel values (0-255) (tab) label (0-9)
  # [0] [1] . . [7] [7] 

  def __init__(self, tmp_x,tmp_y):
    # tmp_x = np.loadtxt(src_file, usecols=[784],
    #   deliminp.loadtxt(src_file, usecols=range(0,7),
    #   delimiter="\t", comments="#", dtype=np.float32)
    # tmp_y = ter="\t", comments="#", dtype=np.int64)
    self.x_data = T.tensor(tmp_x, dtype=T.float32).to(device) 
    # self.x_data /= 255.0  # normalize pixels
    self.y_data = T.tensor(tmp_y, dtype=T.int64).to(device)
    # don't normalize digit labels

  def __len__(self):
    return len(self.x_data)

  def __getitem__(self, idx):
    pixels = self.x_data[idx]
    label = self.y_data[idx]
    return (pixels, label)

# -----------------------------------------------------------
# for the dataset (after reshaping the data)

# def dataset_playa(temp_x,tmp_y):
#   
#   x_data = T.tensor(tmp_x, dtype=T.float32).to(device) 
#   x_data /= 255.0  # normalize pixels
#   y_data = T.tensor(temp_y, dtype=T.int64).to(device)
#   return pixels, label

# -----------------------------------------------------------

class VAE(T.nn.Module):  # [7-6-5-[2,2]-2-5-6-7]
  def __init__(self):
    super(VAE, self).__init__()  
    self.fc1a = T.nn.Linear(7, 6)  # no labels
    self.fc1b = T.nn.Linear(6, 5)  # no labels

    self.fc2a = T.nn.Linear(5, 2)   # u
    self.fc2b = T.nn.Linear(5,2)   # log-var


    self.fc3 = T.nn.Linear(2, 5)
    self.fc4a = T.nn.Linear(5, 6) 
    self.fc4b  = T.nn.Linear(6, 7)

  def encode(self, x):              # 7-6-5-[2,2]  
    z = T.relu(self.fc1a(x)) 
    z = T.relu(self.fc1b(z))
    z1 = self.fc2a(z)               # activation here ??
    z2 = self.fc2b(z) 
    return (z1, z2)                 # (u, log-var)

  def decode(self, x):              # 2-5-6-7
    z = T.relu(self.fc3(x))
    z = T.relu(self.fc4a(z))     
    z = T.sigmoid(self.fc4b(z))      # in [0, 1]
    return z 

  def forward(self, x):
    (u, logvar) = self.encode(x)
    stdev = T.exp(0.5 * logvar)
    noise = T.randn_like(stdev)
    z = u + (noise * stdev)         # [2]
    oupt = self.decode(z)
    return (oupt, u, logvar)

# -----------------------------------------------------------

def cus_loss_func(recon_x, x, u, logvar):
  # https://arxiv.org/abs/1312.6114
  # KLD = 0.5 * sum(1 + log(sigma^2) - u^2 - sigma^2)
  # bce = T.nn.functional.binary_cross_entropy(recon_x, \
  #   x.view(-1, 784), reduction="sum")

  # mse = T.nn.functional.mse_loss(recon_x, x.view(-1, 784))
  mse = T.nn.functional.mse_loss(recon_x, x)

  kld = -0.5 * T.sum(1 + logvar - u.pow(2) - \
    logvar.exp())

  BETA = 1.0
  return mse + (BETA * kld)

# -----------------------------------------------------------

def train(vae, ds, bs, me, lr, le):
  # train autoencoder vae with dataset ds using batch size bs, 
  # with max epochs me, learn rate lr, log_every le
  data_ldr = T.utils.data.DataLoader(ds, batch_size=bs,
    shuffle=True)
  
  # loss_func = T.nn.MSELoss() # use custom loss
  opt = T.optim.SGD(vae.parameters(), lr=lr)
  # print(vae.parameters())
  print("Starting training")
  for epoch in range(0, me):
    for (b_idx, batch) in enumerate(data_ldr):
      opt.zero_grad()
      X = batch[0]  # don't use Y labels to train
      recon_x, u, logvar = vae(X)
      loss_val = cus_loss_func(recon_x, X, u, logvar)
      loss_val.backward()
      opt.step()

    if epoch != 0 and epoch % le == 0:
      print("epoch = %6d" % epoch, end="")
      print("  curr batch loss = %7.4f" % loss_val.item(), end="")
      print("")

      # save and view sample images as sanity check
      # num_images = 64
      # rinpt = T.randn(num_images, 2).to(device)
      # with T.no_grad():
      #   fakes = vae.decode(rinpt)
      # fakes = fakes.view(num_images, 1, 28, 28)
      # tv.utils.save_image(fakes,
      #   ".\\Fakes\\fakes_" + str(epoch) + ".jpg",
      #   padding=4, pad_value=1.0) # no overwrite

  print("Training complete ")

# -----------------------------------------------------------
# divide data in Train - Validation - Test
# X_train, X_test, y_train, y_test = train_test_split(data_reshaped, data_reshaped_test, test_size=0.3, random_state=42)
# X_tr, X_valid, y_tr, y_valid = train_test_split(X_train, y_train, test_size=0.2, random_state=42) 


# -----------------------------------------------------------
def main():
  # 0. get started
  print("\nBegin VAE  ")
  T.manual_seed(1)
  np.random.seed(1)

  # 1. create Dataset object
  print("\nCreating  Dataset ")
  # fn = ".\\Data\\mnist_train_10000.txt"
  # data_ds = MNIST_Dataset(fn)           ############## reshaped dataset here.    #############
  data_ds = dataset_playa(X_train,y_train)
  # print(data_ds.shape)
  # 2. create and train VAE model 
  print("\nCreating VAE  \n")
  vae = VAE()   # 7-5-[2,2]-2-5-7
  vae.train()           # set mode

  # Hyperparameters
  bat_size = 10000
  max_epochs = 40
  lrn_rate = 0.1
  log_every = int(max_epochs / 10)
  train(vae, data_ds, bat_size, max_epochs, \
    lrn_rate, log_every)

  # 3. TODO: save trained VAE

  # 4. use model encoder to generate (x,y) pairs
  vae.eval()
  all_pixels = data_ds[0:1000][0]  # all pixel values
  all_labels = data_ds[0:1000][1]

  with T.no_grad():
    u, logvar = vae.encode(all_pixels) # mean logvar

  print("\nImages reduced to 2 values: ")
  print(u)

  # 5. graph the reduced-form digits in 2D
  # print("\nPlotting reduced-dim images")
  # plt.scatter(u[:,0], u[:,1],
  #           c=all_labels, edgecolor='none', alpha=0.9,
  #           cmap=plt.cm.get_cmap('nipy_spectral', 11),
  #           s=20)  # s=20 orig, alpha=0.9
  # plt.xlabel('mean[0]')
  # plt.ylabel('mean[1]')
  # plt.colorbar()
  # plt.show()
  # plt.savefig()

  print("\nEnd VAE")

# -----------------------------------------------------------

if __name__ == "__main__":
  main()



"""# Elbow Method
The KElbowVisualizer implements the “elbow” method to help data scientists select the optimal number of clusters by fitting the model with a range of values for 𝐾. If the line chart resembles an arm, then the “elbow” (the point of inflection on the curve) is a good indication that the underlying model fits best at that point. In the visualizer “elbow” will be annotated with a dashed line.

To demonstrate, in the following example the KElbowVisualizer fits the KMeans model for a range of 𝐾 values from 4 to 11 on a sample two-dimensional dataset with 8 random clusters of points. When the model is fit with 8 clusters, we can see a line annotating the “elbow” in the graph, which in this case we know to be the optimal number.


"""

from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs

from yellowbrick.cluster import KElbowVisualizer

# Generate synthetic dataset with 8 random clusters
X, y = make_blobs(n_samples=1000, n_features=12, centers=8, random_state=42)

# Instantiate the clustering model and visualizer
model = KMeans()
visualizer = KElbowVisualizer(model, k=(3,9))

visualizer.fit(scores[:,:components_num])        # Fit the data to the visualizer
visualizer.show()        # Finalize and render the figure

